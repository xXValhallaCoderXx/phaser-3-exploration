{"ast":null,"code":"import { SPAWN_TYPE } from \"game-core/utils\";\nimport Spawner from \"./Spawner\";\nimport PlayerModel from \"./PlayerModel\";\n\nclass GameManager {\n  constructor(scene, mapData) {\n    this.scene = scene;\n    this.mapData = mapData;\n    this.spawners = {};\n    this.players = {};\n    this.chests = {};\n    this.monsters = {};\n    this.playerLocations = [];\n    this.chestLocations = {};\n    this.monsterLocations = {};\n  }\n\n  setup() {\n    this.parseMapData();\n    this.setupEventListeners();\n    this.setupSpawners();\n    this.spawnPlayer();\n  }\n  /* \n  Logout\n  My Courses\n  Subscriber Discounts\n  My Account\n  The anchor point of an object is the point of its sprite where its location points to. For example, in Tiled, the location of an object refers to the location of its bottom left corner. On the other hand, in Phaser 3, the default anchor point is the middle of the object.\n  Because of that, when creating a new object from a Tiled map, you need to handle this difference in order to create the object visually in the same location as in the Tiled map.\n  An easy way to fix that is changing the parseMapData method to adjust the locations accordingly, as below. Notice that, instead of using (obj.x, obj.y) we use (obj.x + (obj.width / 2), obj.y – (obj.height / 2)).\n  */\n\n\n  parseMapData() {\n    this.mapData.forEach(layer => {\n      if (layer.name === \"player_locations\") {\n        layer.objects.forEach(obj => this.playerLocations.push([obj.x + obj.width / 2, obj.y - obj.height / 2]));\n      } else if (layer.name === \"chest_locations\") {\n        layer.objects.forEach(obj => {\n          if (this.chestLocations[obj.properties.spawner]) {\n            this.chestLocations[obj.properties.spawner].push([obj.x + obj.width / 2, obj.y - obj.height / 2]);\n          } else {\n            this.chestLocations[obj.properties.spawner] = [[obj.x + obj.width / 2, obj.y - obj.height / 2]];\n          }\n        });\n      } else if (layer.name === \"monster_locations\") {\n        layer.objects.forEach(obj => {\n          if (this.monsterLocations[obj.properties.spawner]) {\n            this.monsterLocations[obj.properties.spawner].push([obj.x + obj.width / 2, obj.y - obj.height / 2]);\n          } else {\n            this.monsterLocations[obj.properties.spawner] = [[obj.x + obj.width / 2, obj.y - obj.height / 2]];\n          }\n        });\n      }\n    });\n  }\n\n  setupEventListeners() {\n    this.scene.events.on(\"pickupChest\", (chestID, playerID) => {\n      // Update spawner\n      if (this.chests[chestID]) {\n        const {\n          gold\n        } = this.chests[chestID];\n        this.players[playerID].updateGold(gold); // Update score\n\n        this.scene.events.emit(\"updateScore\", this.players[playerID].gold); // Check if exists in object array\n        // Get its spawnerID\n        // In spawner ID call remove object\n\n        this.spawners[this.chests[chestID].spawnerId].removeObject(chestID);\n        this.scene.events.emit(\"chestRemoved\", chestID);\n      }\n    });\n    this.scene.events.on(\"monsterAttacked\", (monsterId, playerID) => {\n      // Update spawner\n      if (this.monsters[monsterId]) {\n        // Subtract HP\n        const {\n          gold,\n          attack\n        } = this.monsters[monsterId];\n        this.monsters[monsterId].loseHealth(); // CHeck monster dead then remove\n\n        if (this.monsters[monsterId].health <= 0) {\n          // Update gold\n          this.players[playerID].updateGold(gold);\n          this.scene.events.emit(\"updateScore\", this.players[playerID].gold); // Check if exists in object array\n          // Get its spawnerID\n          // In spawner ID call remove object\n\n          this.spawners[this.monsters[monsterId].spawnerId].removeObject(monsterId);\n          this.scene.events.emit(\"monsterRemoved\", monsterId);\n          this.players[playerID].updateHealth(2);\n          this.scene.events.emit(\"updatePlayerHealth\", playerID, this.players[playerID].health);\n        } else {\n          this.players[playerID].updateHealth(-attack);\n          this.scene.events.emit(\"updateMonsterHealth\", monsterId, this.monsters[monsterId].health);\n          this.scene.events.emit(\"updatePlayerHealth\", playerID, this.players[playerID].health); // Chjeck player halth\n\n          if (this.players[playerID].health <= 0) {\n            this.players[playerID].updateGold(parseInt(-this.players[playerID].gold / 2));\n            this.scene.events.emit(\"updateScore\", this.players[playerID].gold);\n            this.players[playerID].respawn();\n            this.scene.events.emit(\"respawnPlayer\", this.players[playerID]);\n          }\n        }\n      }\n    });\n  }\n\n  setupSpawners() {\n    const config = {\n      spawnInterval: 3000,\n      limit: 3,\n      spawnerType: SPAWN_TYPE.CHEST,\n      id: ``\n    };\n    let spawner;\n    Object.keys(this.chestLocations).forEach(key => {\n      config.id = `chest-${key}`;\n      spawner = new Spawner(config, this.chestLocations[key], this.addChest.bind(this), this.deleteChest.bind(this));\n      this.spawners[spawner.id] = spawner;\n    });\n    Object.keys(this.monsterLocations).forEach(key => {\n      config.id = `monster-${key}`;\n      config.spawnerType = SPAWN_TYPE.MONSTER;\n      spawner = new Spawner(config, this.monsterLocations[key], this.addMonster.bind(this), this.deleteMonster.bind(this), this.moveMonsters.bind(this));\n      this.spawners[spawner.id] = spawner;\n    });\n  }\n\n  spawnPlayer() {\n    const player = new PlayerModel(this.playerLocations);\n    this.players[player.id] = player;\n    this.scene.events.emit(\"spawnPlayer\", player);\n  }\n\n  addChest(id, chest) {\n    this.chests[id] = chest;\n    this.scene.events.emit(\"chestSpawned\", chest);\n  }\n\n  deleteChest(chestId) {\n    delete this.chests[chestId];\n  }\n\n  addMonster(id, monster) {\n    this.monsters[id] = monster;\n    this.scene.events.emit(\"monsterSpawned\", monster);\n  }\n\n  deleteMonster(id) {\n    delete this.monsters[id];\n  }\n\n  moveMonsters() {\n    this.scene.events.emit(\"monsterMovement\", this.monsters);\n  }\n\n}\n\nexport default GameManager;","map":{"version":3,"sources":["/home/odin/Dungeon/Github/phaser-3-exploration/client/src/game-core/classes/game-manager/GameManager.js"],"names":["SPAWN_TYPE","Spawner","PlayerModel","GameManager","constructor","scene","mapData","spawners","players","chests","monsters","playerLocations","chestLocations","monsterLocations","setup","parseMapData","setupEventListeners","setupSpawners","spawnPlayer","forEach","layer","name","objects","obj","push","x","width","y","height","properties","spawner","events","on","chestID","playerID","gold","updateGold","emit","spawnerId","removeObject","monsterId","attack","loseHealth","health","updateHealth","parseInt","respawn","config","spawnInterval","limit","spawnerType","CHEST","id","Object","keys","key","addChest","bind","deleteChest","MONSTER","addMonster","deleteMonster","moveMonsters","player","chest","chestId","monster"],"mappings":"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","sourcesContent":["import { SPAWN_TYPE } from \"game-core/utils\";\nimport Spawner from \"./Spawner\";\nimport PlayerModel from \"./PlayerModel\";\nclass GameManager {\n  constructor(scene, mapData) {\n    this.scene = scene;\n    this.mapData = mapData;\n\n    this.spawners = {};\n    this.players = {};\n    this.chests = {};\n    this.monsters = {};\n    this.playerLocations = [];\n    this.chestLocations = {};\n    this.monsterLocations = {};\n  }\n\n  setup() {\n    this.parseMapData();\n    this.setupEventListeners();\n    this.setupSpawners();\n    this.spawnPlayer();\n  }\n  /* \n\n\nLogout\nMy Courses\nSubscriber Discounts\nMy Account\nThe anchor point of an object is the point of its sprite where its location points to. For example, in Tiled, the location of an object refers to the location of its bottom left corner. On the other hand, in Phaser 3, the default anchor point is the middle of the object.\n\nBecause of that, when creating a new object from a Tiled map, you need to handle this difference in order to create the object visually in the same location as in the Tiled map.\n\nAn easy way to fix that is changing the parseMapData method to adjust the locations accordingly, as below. Notice that, instead of using (obj.x, obj.y) we use (obj.x + (obj.width / 2), obj.y – (obj.height / 2)).\n*/\n  parseMapData() {\n    this.mapData.forEach((layer) => {\n      if (layer.name === \"player_locations\") {\n        layer.objects.forEach((obj) =>\n          this.playerLocations.push([\n            obj.x + obj.width / 2,\n            obj.y - obj.height / 2,\n          ])\n        );\n      } else if (layer.name === \"chest_locations\") {\n        layer.objects.forEach((obj) => {\n          if (this.chestLocations[obj.properties.spawner]) {\n            this.chestLocations[obj.properties.spawner].push([\n              obj.x + obj.width / 2,\n              obj.y - obj.height / 2,\n            ]);\n          } else {\n            this.chestLocations[obj.properties.spawner] = [\n              [obj.x + obj.width / 2, obj.y - obj.height / 2],\n            ];\n          }\n        });\n      } else if (layer.name === \"monster_locations\") {\n        layer.objects.forEach((obj) => {\n          if (this.monsterLocations[obj.properties.spawner]) {\n            this.monsterLocations[obj.properties.spawner].push([\n              obj.x + obj.width / 2,\n              obj.y - obj.height / 2,\n            ]);\n          } else {\n            this.monsterLocations[obj.properties.spawner] = [\n              [obj.x + obj.width / 2, obj.y - obj.height / 2],\n            ];\n          }\n        });\n      }\n    });\n  }\n\n  setupEventListeners() {\n    this.scene.events.on(\"pickupChest\", (chestID, playerID) => {\n      // Update spawner\n      if (this.chests[chestID]) {\n        const { gold } = this.chests[chestID];\n        this.players[playerID].updateGold(gold);\n        // Update score\n        this.scene.events.emit(\"updateScore\", this.players[playerID].gold);\n        // Check if exists in object array\n        // Get its spawnerID\n        // In spawner ID call remove object\n        this.spawners[this.chests[chestID].spawnerId].removeObject(chestID);\n        this.scene.events.emit(\"chestRemoved\", chestID);\n      }\n    });\n    this.scene.events.on(\"monsterAttacked\", (monsterId, playerID) => {\n      // Update spawner\n      if (this.monsters[monsterId]) {\n        // Subtract HP\n        const { gold, attack } = this.monsters[monsterId];\n        this.monsters[monsterId].loseHealth();\n\n        // CHeck monster dead then remove\n        if (this.monsters[monsterId].health <= 0) {\n          // Update gold\n          this.players[playerID].updateGold(gold);\n          this.scene.events.emit(\"updateScore\", this.players[playerID].gold);\n          // Check if exists in object array\n          // Get its spawnerID\n          // In spawner ID call remove object\n          this.spawners[this.monsters[monsterId].spawnerId].removeObject(\n            monsterId\n          );\n          this.scene.events.emit(\"monsterRemoved\", monsterId);\n          this.players[playerID].updateHealth(2);\n          this.scene.events.emit(\n            \"updatePlayerHealth\",\n            playerID,\n            this.players[playerID].health\n          );\n        } else {\n          this.players[playerID].updateHealth(-attack);\n          this.scene.events.emit(\n            \"updateMonsterHealth\",\n            monsterId,\n            this.monsters[monsterId].health\n          );\n\n          this.scene.events.emit(\n            \"updatePlayerHealth\",\n            playerID,\n            this.players[playerID].health\n          );\n\n          // Chjeck player halth\n          if (this.players[playerID].health <= 0) {\n            this.players[playerID].updateGold(\n              parseInt(-this.players[playerID].gold / 2)\n            );\n            this.scene.events.emit(\"updateScore\", this.players[playerID].gold);\n            this.players[playerID].respawn();\n            this.scene.events.emit(\"respawnPlayer\", this.players[playerID]);\n          }\n        }\n      }\n    });\n  }\n  setupSpawners() {\n    const config = {\n      spawnInterval: 3000,\n      limit: 3,\n      spawnerType: SPAWN_TYPE.CHEST,\n      id: ``,\n    };\n    let spawner;\n\n    Object.keys(this.chestLocations).forEach((key) => {\n      config.id = `chest-${key}`;\n      spawner = new Spawner(\n        config,\n        this.chestLocations[key],\n        this.addChest.bind(this),\n        this.deleteChest.bind(this)\n      );\n      this.spawners[spawner.id] = spawner;\n    });\n\n    Object.keys(this.monsterLocations).forEach((key) => {\n      config.id = `monster-${key}`;\n      config.spawnerType = SPAWN_TYPE.MONSTER;\n\n      spawner = new Spawner(\n        config,\n        this.monsterLocations[key],\n        this.addMonster.bind(this),\n        this.deleteMonster.bind(this),\n        this.moveMonsters.bind(this)\n      );\n      this.spawners[spawner.id] = spawner;\n    });\n  }\n  spawnPlayer() {\n    const player = new PlayerModel(this.playerLocations);\n    this.players[player.id] = player;\n    this.scene.events.emit(\"spawnPlayer\", player);\n  }\n\n  addChest(id, chest) {\n    this.chests[id] = chest;\n    this.scene.events.emit(\"chestSpawned\", chest);\n  }\n\n  deleteChest(chestId) {\n    delete this.chests[chestId];\n  }\n\n  addMonster(id, monster) {\n    this.monsters[id] = monster;\n    this.scene.events.emit(\"monsterSpawned\", monster);\n  }\n\n  deleteMonster(id) {\n    delete this.monsters[id];\n  }\n\n  moveMonsters() {\n    this.scene.events.emit(\"monsterMovement\", this.monsters);\n  }\n}\n\nexport default GameManager;\n"]},"metadata":{},"sourceType":"module"}