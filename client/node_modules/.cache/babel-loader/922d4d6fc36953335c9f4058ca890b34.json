{"ast":null,"code":"import Phaser from \"phaser\";\nimport PlayerContainer from \"game-core/classes/player/PlayerContainer\";\nimport Chest from \"game-core/classes/Chest\";\nimport Monster from \"game-core/classes/Monster\";\nimport Map from \"game-core/classes/Map\";\nimport SocketService from \"shared/services/socket/socket-service\";\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super(\"Game\");\n    this.socket = SocketService === null || SocketService === void 0 ? void 0 : SocketService.socket;\n  }\n\n  init() {\n    // Launch instead of start will run scene in parallele - what ever scene active 1st is on bittom lauyet\n    // Start will shut down current and switch to new\n    this.scene.launch(\"Ui\"); // listen for socket event\n\n    this.listenForSocketEvents();\n  }\n\n  listenForSocketEvents() {\n    // spawn player game objects\n    this.socket.on('currentPlayers', players => {\n      Object.keys(players).forEach(id => {\n        if (players[id].id === this.socket.id) {\n          this.createPlayer(players[id], true);\n          this.addCollisions();\n        } else {\n          this.createPlayer(players[id], false);\n        }\n      });\n    }); // spawn monster game objects\n\n    this.socket.on('currentMonsters', monsters => {\n      Object.keys(monsters).forEach(id => {\n        this.spawnMonster(monsters[id]);\n      });\n    }); // spawn chest game objects\n\n    this.socket.on('currentChests', chests => {\n      Object.keys(chests).forEach(id => {\n        this.spawnChest(chests[id]);\n      });\n    }); // spawn player game object\n\n    this.socket.on('spawnPlayer', player => {\n      this.createPlayer(player, false);\n    }); // a player has moved\n\n    this.socket.on('playerMoved', player => {\n      this.otherPlayers.getChildren().forEach(otherPlayer => {\n        if (player.id === otherPlayer.id) {\n          otherPlayer.flipX = player.flipX;\n          otherPlayer.setPosition(player.x, player.y);\n          otherPlayer.updateHealthBar();\n          otherPlayer.updateFlipX();\n          otherPlayer.playerAttacking = player.playerAttacking;\n          otherPlayer.currentDirection = player.currentDirection;\n\n          if (player.playerAttacking) {\n            otherPlayer.attack();\n          }\n        }\n      });\n    });\n    this.socket.on('chestSpawned', chest => {\n      this.spawnChest(chest);\n    });\n    this.socket.on('monsterSpawned', monster => {\n      this.spawnMonster(monster);\n    });\n    this.socket.on('chestRemoved', chestId => {\n      this.chests.getChildren().forEach(chest => {\n        if (chest.id === chestId) {\n          chest.makeInactive();\n        }\n      });\n    });\n    this.socket.on('monsterRemoved', monsterId => {\n      this.monsters.getChildren().forEach(monster => {\n        if (monster.id === monsterId) {\n          monster.makeInactive();\n          this.monsterDeathAudio.play();\n        }\n      });\n    });\n    this.socket.on('monsterMovement', monsters => {\n      this.monsters.getChildren().forEach(monster => {\n        Object.keys(monsters).forEach(monsterId => {\n          if (monster.id === monsterId) {\n            this.physics.moveToObject(monster, monsters[monsterId], 40);\n          }\n        });\n      });\n    });\n    this.socket.on('updateScore', goldAmount => {\n      this.events.emit('updateScore', goldAmount);\n    });\n    this.socket.on('updateMonsterHealth', (monsterId, health) => {\n      this.monsters.getChildren().forEach(monster => {\n        if (monster.id === monsterId) {\n          monster.updateHealth(health);\n        }\n      });\n    });\n    this.socket.on('updatePlayerHealth', (playerId, health) => {\n      if (this.player.id === playerId) {\n        if (health < this.player.health) {\n          this.playerDamageAudio.play();\n        }\n\n        this.player.updateHealth(health);\n      } else {\n        this.otherPlayers.getChildren().forEach(player => {\n          if (player.id === playerId) {\n            player.updateHealth(health);\n          }\n        });\n      }\n    });\n    this.socket.on('respawnPlayer', playerObject => {\n      if (this.player.id === playerObject.id) {\n        this.playerDeathAudio.play();\n        this.player.respawn(playerObject);\n      } else {\n        this.otherPlayers.getChildren().forEach(player => {\n          if (player.id === playerObject.id) {\n            player.respawn(playerObject);\n          }\n        });\n      }\n    });\n    this.socket.on('disconnect', playerId => {\n      this.otherPlayers.getChildren().forEach(player => {\n        if (playerId === player.id) {\n          player.cleanUp();\n        }\n      });\n    });\n    this.socket.on('invalidToken', () => {\n      window.alert('Token is no longer valid. Please login again.');\n      window.location.reload();\n    });\n  }\n\n  create() {\n    this.createMap();\n    this.createAudio();\n    this.createGroups();\n    this.createInput(); // emit event to server that a new player joined\n\n    this.socket.emit('newPlayer', {\n      test: 1234\n    });\n  }\n\n  update() {\n    if (this.player) this.player.update(this.cursors);\n\n    if (this.player) {\n      // emit player movement to the server\n      const {\n        x,\n        y,\n        flipX,\n        playerAttacking,\n        currentDirection\n      } = this.player;\n\n      if (this.player.oldPosition && (x !== this.player.oldPosition.x || y !== this.player.oldPosition.y || flipX !== this.player.oldPosition.flipX || playerAttacking !== this.player.oldPosition.playerAttacking)) {\n        this.socket.emit('playerMovement', {\n          x,\n          y,\n          flipX,\n          playerAttacking,\n          currentDirection\n        });\n      } // save old position data\n\n\n      this.player.oldPosition = {\n        x: this.player.x,\n        y: this.player.y,\n        flipX: this.player.flipX,\n        playerAttacking: this.player.playerAttacking\n      };\n    }\n  }\n\n  createAudio() {\n    this.goldPickupAudio = this.sound.add('goldSound', {\n      loop: false,\n      volume: 0.3\n    });\n    this.playerAttackAudio = this.sound.add('playerAttack', {\n      loop: false,\n      volume: 0.01\n    });\n    this.playerDamageAudio = this.sound.add('playerDamage', {\n      loop: false,\n      volume: 0.2\n    });\n    this.playerDeathAudio = this.sound.add('playerDeath', {\n      loop: false,\n      volume: 0.2\n    });\n    this.monsterDeathAudio = this.sound.add('enemyDeath', {\n      loop: false,\n      volume: 0.2\n    });\n  }\n\n  createPlayer(playerObject, mainPlayer) {\n    const newPlayerGameObject = new PlayerContainer(this, playerObject.x * 2, playerObject.y * 2, 'characters', 0, playerObject.health, playerObject.maxHealth, playerObject.id, this.playerAttackAudio, mainPlayer);\n\n    if (!mainPlayer) {\n      this.otherPlayers.add(newPlayerGameObject);\n    } else {\n      this.player = newPlayerGameObject;\n    }\n  }\n\n  createGroups() {\n    // create a chest group\n    this.chests = this.physics.add.group(); // create a monster group\n\n    this.monsters = this.physics.add.group();\n    this.monsters.runChildUpdate = true; // create an other players group\n\n    this.otherPlayers = this.physics.add.group();\n    this.otherPlayers.runChildUpdate = true;\n  }\n\n  spawnChest(chestObject) {\n    let chest = this.chests.getFirstDead();\n\n    if (!chest) {\n      chest = new Chest(this, chestObject.x * 2, chestObject.y * 2, 'items', 0, chestObject.gold, chestObject.id); // add chest to chests group\n\n      this.chests.add(chest);\n    } else {\n      chest.coins = chestObject.gold;\n      chest.id = chestObject.id;\n      chest.setPosition(chestObject.x * 2, chestObject.y * 2);\n      chest.makeActive();\n    }\n  }\n\n  spawnMonster(monsterObject) {\n    let monster = this.monsters.getFirstDead();\n\n    if (!monster) {\n      monster = new Monster(this, monsterObject.x, monsterObject.y, 'monsters', monsterObject.frame, monsterObject.id, monsterObject.health, monsterObject.maxHealth); // add monster to monsters group\n\n      this.monsters.add(monster);\n    } else {\n      monster.id = monsterObject.id;\n      monster.health = monsterObject.health;\n      monster.maxHealth = monsterObject.maxHealth;\n      monster.setTexture('monsters', monsterObject.frame);\n      monster.setPosition(monsterObject.x, monsterObject.y);\n      monster.makeActive();\n    }\n  }\n\n  createInput() {\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  addCollisions() {\n    // check for collisions between the player and the tiled blocked layer\n    this.physics.add.collider(this.player, this.map.blockedLayer); // check for overlaps between player and chest game objects\n\n    this.physics.add.overlap(this.player, this.chests, this.collectChest, null, this); // check for collisions between the monster group and the tiled blocked layer\n\n    this.physics.add.collider(this.monsters, this.map.blockedLayer); // check for overlaps between the player's weapon and monster game objects\n\n    this.physics.add.overlap(this.player.weapon, this.monsters, this.enemyOverlap, null, this); // check for collision betwen the player and other players\n\n    this.physics.add.collider(this.otherPlayers, this.player, this.pvpCollider, false, this); // check for overlaps between the player's weapon and other player game objects\n\n    this.physics.add.overlap(this.player.weapon, this.otherPlayers, this.weaponOverlapEnemy, false, this);\n  }\n\n  pvpCollider(player, otherPlayer) {\n    this.player.body.setVelocity(0);\n    otherPlayer.body.setVelocity(0);\n  }\n\n  weaponOverlapEnemy(player, enemyPlayer) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true;\n      this.socket.emit('attackedPlayer', enemyPlayer.id);\n    }\n  }\n\n  enemyOverlap(weapon, enemy) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true;\n      this.socket.emit('monsterAttacked', enemy.id);\n    }\n  }\n\n  collectChest(player, chest) {\n    // play gold pickup sound\n    this.goldPickupAudio.play();\n    this.socket.emit('pickUpChest', chest.id);\n  }\n\n  createMap() {\n    this.map = new Map(this, \"map\", \"background\", \"background\", \"blocked\");\n  }\n\n}\n\nexport default GameScene;","map":{"version":3,"sources":["/home/odin/Dungeon/Github/phaser-3-exploration/client/src/game-core/scenes/GameScene.js"],"names":["Phaser","PlayerContainer","Chest","Monster","Map","SocketService","GameScene","Scene","constructor","socket","init","scene","launch","listenForSocketEvents","on","players","Object","keys","forEach","id","createPlayer","addCollisions","monsters","spawnMonster","chests","spawnChest","player","otherPlayers","getChildren","otherPlayer","flipX","setPosition","x","y","updateHealthBar","updateFlipX","playerAttacking","currentDirection","attack","chest","monster","chestId","makeInactive","monsterId","monsterDeathAudio","play","physics","moveToObject","goldAmount","events","emit","health","updateHealth","playerId","playerDamageAudio","playerObject","playerDeathAudio","respawn","cleanUp","window","alert","location","reload","create","createMap","createAudio","createGroups","createInput","test","update","cursors","oldPosition","goldPickupAudio","sound","add","loop","volume","playerAttackAudio","mainPlayer","newPlayerGameObject","maxHealth","group","runChildUpdate","chestObject","getFirstDead","gold","coins","makeActive","monsterObject","frame","setTexture","input","keyboard","createCursorKeys","collider","map","blockedLayer","overlap","collectChest","weapon","enemyOverlap","pvpCollider","weaponOverlapEnemy","body","setVelocity","enemyPlayer","swordHit","enemy"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,eAAP,MAA4B,0CAA5B;AACA,OAAOC,KAAP,MAAkB,yBAAlB;AACA,OAAOC,OAAP,MAAoB,2BAApB;AACA,OAAOC,GAAP,MAAgB,uBAAhB;AACA,OAAOC,aAAP,MAA0B,uCAA1B;;AAEA,MAAMC,SAAN,SAAwBN,MAAM,CAACO,KAA/B,CAAqC;AACnCC,EAAAA,WAAW,GAAG;AACZ,UAAM,MAAN;AAEA,SAAKC,MAAL,GAAcJ,aAAd,aAAcA,aAAd,uBAAcA,aAAa,CAAEI,MAA7B;AACD;;AAEDC,EAAAA,IAAI,GAAG;AACL;AACA;AACA,SAAKC,KAAL,CAAWC,MAAX,CAAkB,IAAlB,EAHK,CAML;;AACA,SAAKC,qBAAL;AACD;;AAEDA,EAAAA,qBAAqB,GAAG;AACtB;AACA,SAAKJ,MAAL,CAAYK,EAAZ,CAAe,gBAAf,EAAkCC,OAAD,IAAa;AAC5CC,MAAAA,MAAM,CAACC,IAAP,CAAYF,OAAZ,EAAqBG,OAArB,CAA8BC,EAAD,IAAQ;AACnC,YAAIJ,OAAO,CAACI,EAAD,CAAP,CAAYA,EAAZ,KAAmB,KAAKV,MAAL,CAAYU,EAAnC,EAAuC;AACrC,eAAKC,YAAL,CAAkBL,OAAO,CAACI,EAAD,CAAzB,EAA+B,IAA/B;AACA,eAAKE,aAAL;AACD,SAHD,MAGO;AACL,eAAKD,YAAL,CAAkBL,OAAO,CAACI,EAAD,CAAzB,EAA+B,KAA/B;AACD;AACF,OAPD;AAQD,KATD,EAFsB,CAatB;;AACA,SAAKV,MAAL,CAAYK,EAAZ,CAAe,iBAAf,EAAmCQ,QAAD,IAAc;AAC9CN,MAAAA,MAAM,CAACC,IAAP,CAAYK,QAAZ,EAAsBJ,OAAtB,CAA+BC,EAAD,IAAQ;AACpC,aAAKI,YAAL,CAAkBD,QAAQ,CAACH,EAAD,CAA1B;AACD,OAFD;AAGD,KAJD,EAdsB,CAoBtB;;AACA,SAAKV,MAAL,CAAYK,EAAZ,CAAe,eAAf,EAAiCU,MAAD,IAAY;AAC1CR,MAAAA,MAAM,CAACC,IAAP,CAAYO,MAAZ,EAAoBN,OAApB,CAA6BC,EAAD,IAAQ;AAClC,aAAKM,UAAL,CAAgBD,MAAM,CAACL,EAAD,CAAtB;AACD,OAFD;AAGD,KAJD,EArBsB,CA2BtB;;AACA,SAAKV,MAAL,CAAYK,EAAZ,CAAe,aAAf,EAA+BY,MAAD,IAAY;AACxC,WAAKN,YAAL,CAAkBM,MAAlB,EAA0B,KAA1B;AACD,KAFD,EA5BsB,CAgCtB;;AACA,SAAKjB,MAAL,CAAYK,EAAZ,CAAe,aAAf,EAA+BY,MAAD,IAAY;AACxC,WAAKC,YAAL,CAAkBC,WAAlB,GAAgCV,OAAhC,CAAyCW,WAAD,IAAiB;AACvD,YAAIH,MAAM,CAACP,EAAP,KAAcU,WAAW,CAACV,EAA9B,EAAkC;AAChCU,UAAAA,WAAW,CAACC,KAAZ,GAAoBJ,MAAM,CAACI,KAA3B;AACAD,UAAAA,WAAW,CAACE,WAAZ,CAAwBL,MAAM,CAACM,CAA/B,EAAkCN,MAAM,CAACO,CAAzC;AACAJ,UAAAA,WAAW,CAACK,eAAZ;AACAL,UAAAA,WAAW,CAACM,WAAZ;AACAN,UAAAA,WAAW,CAACO,eAAZ,GAA8BV,MAAM,CAACU,eAArC;AACAP,UAAAA,WAAW,CAACQ,gBAAZ,GAA+BX,MAAM,CAACW,gBAAtC;;AACA,cAAIX,MAAM,CAACU,eAAX,EAA4B;AAC1BP,YAAAA,WAAW,CAACS,MAAZ;AACD;AACF;AACF,OAZD;AAaD,KAdD;AAgBA,SAAK7B,MAAL,CAAYK,EAAZ,CAAe,cAAf,EAAgCyB,KAAD,IAAW;AACxC,WAAKd,UAAL,CAAgBc,KAAhB;AACD,KAFD;AAIA,SAAK9B,MAAL,CAAYK,EAAZ,CAAe,gBAAf,EAAkC0B,OAAD,IAAa;AAC5C,WAAKjB,YAAL,CAAkBiB,OAAlB;AACD,KAFD;AAIA,SAAK/B,MAAL,CAAYK,EAAZ,CAAe,cAAf,EAAgC2B,OAAD,IAAa;AAC1C,WAAKjB,MAAL,CAAYI,WAAZ,GAA0BV,OAA1B,CAAmCqB,KAAD,IAAW;AAC3C,YAAIA,KAAK,CAACpB,EAAN,KAAasB,OAAjB,EAA0B;AACxBF,UAAAA,KAAK,CAACG,YAAN;AACD;AACF,OAJD;AAKD,KAND;AAQA,SAAKjC,MAAL,CAAYK,EAAZ,CAAe,gBAAf,EAAkC6B,SAAD,IAAe;AAC9C,WAAKrB,QAAL,CAAcM,WAAd,GAA4BV,OAA5B,CAAqCsB,OAAD,IAAa;AAC/C,YAAIA,OAAO,CAACrB,EAAR,KAAewB,SAAnB,EAA8B;AAC5BH,UAAAA,OAAO,CAACE,YAAR;AACA,eAAKE,iBAAL,CAAuBC,IAAvB;AACD;AACF,OALD;AAMD,KAPD;AASA,SAAKpC,MAAL,CAAYK,EAAZ,CAAe,iBAAf,EAAmCQ,QAAD,IAAc;AAC9C,WAAKA,QAAL,CAAcM,WAAd,GAA4BV,OAA5B,CAAqCsB,OAAD,IAAa;AAC/CxB,QAAAA,MAAM,CAACC,IAAP,CAAYK,QAAZ,EAAsBJ,OAAtB,CAA+ByB,SAAD,IAAe;AAC3C,cAAIH,OAAO,CAACrB,EAAR,KAAewB,SAAnB,EAA8B;AAC5B,iBAAKG,OAAL,CAAaC,YAAb,CAA0BP,OAA1B,EAAmClB,QAAQ,CAACqB,SAAD,CAA3C,EAAwD,EAAxD;AACD;AACF,SAJD;AAKD,OAND;AAOD,KARD;AAUA,SAAKlC,MAAL,CAAYK,EAAZ,CAAe,aAAf,EAA+BkC,UAAD,IAAgB;AAC5C,WAAKC,MAAL,CAAYC,IAAZ,CAAiB,aAAjB,EAAgCF,UAAhC;AACD,KAFD;AAIA,SAAKvC,MAAL,CAAYK,EAAZ,CAAe,qBAAf,EAAsC,CAAC6B,SAAD,EAAYQ,MAAZ,KAAuB;AAC3D,WAAK7B,QAAL,CAAcM,WAAd,GAA4BV,OAA5B,CAAqCsB,OAAD,IAAa;AAC/C,YAAIA,OAAO,CAACrB,EAAR,KAAewB,SAAnB,EAA8B;AAC5BH,UAAAA,OAAO,CAACY,YAAR,CAAqBD,MAArB;AACD;AACF,OAJD;AAKD,KAND;AAQA,SAAK1C,MAAL,CAAYK,EAAZ,CAAe,oBAAf,EAAqC,CAACuC,QAAD,EAAWF,MAAX,KAAsB;AACzD,UAAI,KAAKzB,MAAL,CAAYP,EAAZ,KAAmBkC,QAAvB,EAAiC;AAC/B,YAAIF,MAAM,GAAG,KAAKzB,MAAL,CAAYyB,MAAzB,EAAiC;AAC/B,eAAKG,iBAAL,CAAuBT,IAAvB;AACD;;AACD,aAAKnB,MAAL,CAAY0B,YAAZ,CAAyBD,MAAzB;AACD,OALD,MAKO;AACL,aAAKxB,YAAL,CAAkBC,WAAlB,GAAgCV,OAAhC,CAAyCQ,MAAD,IAAY;AAClD,cAAIA,MAAM,CAACP,EAAP,KAAckC,QAAlB,EAA4B;AAC1B3B,YAAAA,MAAM,CAAC0B,YAAP,CAAoBD,MAApB;AACD;AACF,SAJD;AAKD;AACF,KAbD;AAeA,SAAK1C,MAAL,CAAYK,EAAZ,CAAe,eAAf,EAAiCyC,YAAD,IAAkB;AAChD,UAAI,KAAK7B,MAAL,CAAYP,EAAZ,KAAmBoC,YAAY,CAACpC,EAApC,EAAwC;AACtC,aAAKqC,gBAAL,CAAsBX,IAAtB;AACA,aAAKnB,MAAL,CAAY+B,OAAZ,CAAoBF,YAApB;AACD,OAHD,MAGO;AACL,aAAK5B,YAAL,CAAkBC,WAAlB,GAAgCV,OAAhC,CAAyCQ,MAAD,IAAY;AAClD,cAAIA,MAAM,CAACP,EAAP,KAAcoC,YAAY,CAACpC,EAA/B,EAAmC;AACjCO,YAAAA,MAAM,CAAC+B,OAAP,CAAeF,YAAf;AACD;AACF,SAJD;AAKD;AACF,KAXD;AAaA,SAAK9C,MAAL,CAAYK,EAAZ,CAAe,YAAf,EAA8BuC,QAAD,IAAc;AACzC,WAAK1B,YAAL,CAAkBC,WAAlB,GAAgCV,OAAhC,CAAyCQ,MAAD,IAAY;AAClD,YAAI2B,QAAQ,KAAK3B,MAAM,CAACP,EAAxB,EAA4B;AAC1BO,UAAAA,MAAM,CAACgC,OAAP;AACD;AACF,OAJD;AAKD,KAND;AAQA,SAAKjD,MAAL,CAAYK,EAAZ,CAAe,cAAf,EAA+B,MAAM;AACnC6C,MAAAA,MAAM,CAACC,KAAP,CAAa,+CAAb;AACAD,MAAAA,MAAM,CAACE,QAAP,CAAgBC,MAAhB;AACD,KAHD;AAID;;AAIDC,EAAAA,MAAM,GAAG;AACP,SAAKC,SAAL;AACA,SAAKC,WAAL;AACA,SAAKC,YAAL;AACA,SAAKC,WAAL,GAJO,CAMP;;AACA,SAAK1D,MAAL,CAAYyC,IAAZ,CAAiB,WAAjB,EAA8B;AAAEkB,MAAAA,IAAI,EAAE;AAAR,KAA9B;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACP,QAAI,KAAK3C,MAAT,EAAiB,KAAKA,MAAL,CAAY2C,MAAZ,CAAmB,KAAKC,OAAxB;;AAEjB,QAAI,KAAK5C,MAAT,EAAiB;AACf;AACA,YAAM;AACJM,QAAAA,CADI;AACDC,QAAAA,CADC;AACEH,QAAAA,KADF;AACSM,QAAAA,eADT;AAC0BC,QAAAA;AAD1B,UAEF,KAAKX,MAFT;;AAGA,UAAI,KAAKA,MAAL,CAAY6C,WAAZ,KAA4BvC,CAAC,KAAK,KAAKN,MAAL,CAAY6C,WAAZ,CAAwBvC,CAA9B,IAC3BC,CAAC,KAAK,KAAKP,MAAL,CAAY6C,WAAZ,CAAwBtC,CADH,IACQH,KAAK,KAAK,KAAKJ,MAAL,CAAY6C,WAAZ,CAAwBzC,KAD1C,IAE3BM,eAAe,KAAK,KAAKV,MAAL,CAAY6C,WAAZ,CAAwBnC,eAF7C,CAAJ,EAEmE;AACjE,aAAK3B,MAAL,CAAYyC,IAAZ,CAAiB,gBAAjB,EAAmC;AACjClB,UAAAA,CADiC;AAC9BC,UAAAA,CAD8B;AAC3BH,UAAAA,KAD2B;AACpBM,UAAAA,eADoB;AACHC,UAAAA;AADG,SAAnC;AAGD,OAXc,CAaf;;;AACA,WAAKX,MAAL,CAAY6C,WAAZ,GAA0B;AACxBvC,QAAAA,CAAC,EAAE,KAAKN,MAAL,CAAYM,CADS;AAExBC,QAAAA,CAAC,EAAE,KAAKP,MAAL,CAAYO,CAFS;AAGxBH,QAAAA,KAAK,EAAE,KAAKJ,MAAL,CAAYI,KAHK;AAIxBM,QAAAA,eAAe,EAAE,KAAKV,MAAL,CAAYU;AAJL,OAA1B;AAMD;AACF;;AAGD6B,EAAAA,WAAW,GAAG;AACZ,SAAKO,eAAL,GAAuB,KAAKC,KAAL,CAAWC,GAAX,CAAe,WAAf,EAA4B;AAAEC,MAAAA,IAAI,EAAE,KAAR;AAAeC,MAAAA,MAAM,EAAE;AAAvB,KAA5B,CAAvB;AACA,SAAKC,iBAAL,GAAyB,KAAKJ,KAAL,CAAWC,GAAX,CAAe,cAAf,EAA+B;AAAEC,MAAAA,IAAI,EAAE,KAAR;AAAeC,MAAAA,MAAM,EAAE;AAAvB,KAA/B,CAAzB;AACA,SAAKtB,iBAAL,GAAyB,KAAKmB,KAAL,CAAWC,GAAX,CAAe,cAAf,EAA+B;AAAEC,MAAAA,IAAI,EAAE,KAAR;AAAeC,MAAAA,MAAM,EAAE;AAAvB,KAA/B,CAAzB;AACA,SAAKpB,gBAAL,GAAwB,KAAKiB,KAAL,CAAWC,GAAX,CAAe,aAAf,EAA8B;AAAEC,MAAAA,IAAI,EAAE,KAAR;AAAeC,MAAAA,MAAM,EAAE;AAAvB,KAA9B,CAAxB;AACA,SAAKhC,iBAAL,GAAyB,KAAK6B,KAAL,CAAWC,GAAX,CAAe,YAAf,EAA6B;AAAEC,MAAAA,IAAI,EAAE,KAAR;AAAeC,MAAAA,MAAM,EAAE;AAAvB,KAA7B,CAAzB;AACD;;AAEDxD,EAAAA,YAAY,CAACmC,YAAD,EAAeuB,UAAf,EAA2B;AACrC,UAAMC,mBAAmB,GAAG,IAAI9E,eAAJ,CAC1B,IAD0B,EAE1BsD,YAAY,CAACvB,CAAb,GAAiB,CAFS,EAG1BuB,YAAY,CAACtB,CAAb,GAAiB,CAHS,EAI1B,YAJ0B,EAK1B,CAL0B,EAM1BsB,YAAY,CAACJ,MANa,EAO1BI,YAAY,CAACyB,SAPa,EAQ1BzB,YAAY,CAACpC,EARa,EAS1B,KAAK0D,iBATqB,EAU1BC,UAV0B,CAA5B;;AAaA,QAAI,CAACA,UAAL,EAAiB;AACf,WAAKnD,YAAL,CAAkB+C,GAAlB,CAAsBK,mBAAtB;AACD,KAFD,MAEO;AACL,WAAKrD,MAAL,GAAcqD,mBAAd;AACD;AACF;;AAGDb,EAAAA,YAAY,GAAG;AACb;AACA,SAAK1C,MAAL,GAAc,KAAKsB,OAAL,CAAa4B,GAAb,CAAiBO,KAAjB,EAAd,CAFa,CAGb;;AACA,SAAK3D,QAAL,GAAgB,KAAKwB,OAAL,CAAa4B,GAAb,CAAiBO,KAAjB,EAAhB;AACA,SAAK3D,QAAL,CAAc4D,cAAd,GAA+B,IAA/B,CALa,CAMb;;AACA,SAAKvD,YAAL,GAAoB,KAAKmB,OAAL,CAAa4B,GAAb,CAAiBO,KAAjB,EAApB;AACA,SAAKtD,YAAL,CAAkBuD,cAAlB,GAAmC,IAAnC;AACD;;AAEDzD,EAAAA,UAAU,CAAC0D,WAAD,EAAc;AACtB,QAAI5C,KAAK,GAAG,KAAKf,MAAL,CAAY4D,YAAZ,EAAZ;;AACA,QAAI,CAAC7C,KAAL,EAAY;AACVA,MAAAA,KAAK,GAAG,IAAIrC,KAAJ,CAAU,IAAV,EAAgBiF,WAAW,CAACnD,CAAZ,GAAgB,CAAhC,EAAmCmD,WAAW,CAAClD,CAAZ,GAAgB,CAAnD,EAAsD,OAAtD,EAA+D,CAA/D,EAAkEkD,WAAW,CAACE,IAA9E,EAAoFF,WAAW,CAAChE,EAAhG,CAAR,CADU,CAEV;;AACA,WAAKK,MAAL,CAAYkD,GAAZ,CAAgBnC,KAAhB;AACD,KAJD,MAIO;AACLA,MAAAA,KAAK,CAAC+C,KAAN,GAAcH,WAAW,CAACE,IAA1B;AACA9C,MAAAA,KAAK,CAACpB,EAAN,GAAWgE,WAAW,CAAChE,EAAvB;AACAoB,MAAAA,KAAK,CAACR,WAAN,CAAkBoD,WAAW,CAACnD,CAAZ,GAAgB,CAAlC,EAAqCmD,WAAW,CAAClD,CAAZ,GAAgB,CAArD;AACAM,MAAAA,KAAK,CAACgD,UAAN;AACD;AACF;;AAEDhE,EAAAA,YAAY,CAACiE,aAAD,EAAgB;AAC1B,QAAIhD,OAAO,GAAG,KAAKlB,QAAL,CAAc8D,YAAd,EAAd;;AACA,QAAI,CAAC5C,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAG,IAAIrC,OAAJ,CACR,IADQ,EAERqF,aAAa,CAACxD,CAFN,EAGRwD,aAAa,CAACvD,CAHN,EAIR,UAJQ,EAKRuD,aAAa,CAACC,KALN,EAMRD,aAAa,CAACrE,EANN,EAORqE,aAAa,CAACrC,MAPN,EAQRqC,aAAa,CAACR,SARN,CAAV,CADY,CAWZ;;AACA,WAAK1D,QAAL,CAAcoD,GAAd,CAAkBlC,OAAlB;AACD,KAbD,MAaO;AACLA,MAAAA,OAAO,CAACrB,EAAR,GAAaqE,aAAa,CAACrE,EAA3B;AACAqB,MAAAA,OAAO,CAACW,MAAR,GAAiBqC,aAAa,CAACrC,MAA/B;AACAX,MAAAA,OAAO,CAACwC,SAAR,GAAoBQ,aAAa,CAACR,SAAlC;AACAxC,MAAAA,OAAO,CAACkD,UAAR,CAAmB,UAAnB,EAA+BF,aAAa,CAACC,KAA7C;AACAjD,MAAAA,OAAO,CAACT,WAAR,CAAoByD,aAAa,CAACxD,CAAlC,EAAqCwD,aAAa,CAACvD,CAAnD;AACAO,MAAAA,OAAO,CAAC+C,UAAR;AACD;AACF;;AAGDpB,EAAAA,WAAW,GAAG;AACZ,SAAKG,OAAL,GAAe,KAAKqB,KAAL,CAAWC,QAAX,CAAoBC,gBAApB,EAAf;AACD;;AAEDxE,EAAAA,aAAa,GAAG;AACd;AACA,SAAKyB,OAAL,CAAa4B,GAAb,CAAiBoB,QAAjB,CAA0B,KAAKpE,MAA/B,EAAuC,KAAKqE,GAAL,CAASC,YAAhD,EAFc,CAGd;;AACA,SAAKlD,OAAL,CAAa4B,GAAb,CAAiBuB,OAAjB,CAAyB,KAAKvE,MAA9B,EAAsC,KAAKF,MAA3C,EAAmD,KAAK0E,YAAxD,EAAsE,IAAtE,EAA4E,IAA5E,EAJc,CAKd;;AACA,SAAKpD,OAAL,CAAa4B,GAAb,CAAiBoB,QAAjB,CAA0B,KAAKxE,QAA/B,EAAyC,KAAKyE,GAAL,CAASC,YAAlD,EANc,CAOd;;AACA,SAAKlD,OAAL,CAAa4B,GAAb,CAAiBuB,OAAjB,CAAyB,KAAKvE,MAAL,CAAYyE,MAArC,EAA6C,KAAK7E,QAAlD,EAA4D,KAAK8E,YAAjE,EAA+E,IAA/E,EAAqF,IAArF,EARc,CASd;;AACA,SAAKtD,OAAL,CAAa4B,GAAb,CAAiBoB,QAAjB,CAA0B,KAAKnE,YAA/B,EAA6C,KAAKD,MAAlD,EAA0D,KAAK2E,WAA/D,EAA4E,KAA5E,EAAmF,IAAnF,EAVc,CAWd;;AACA,SAAKvD,OAAL,CAAa4B,GAAb,CAAiBuB,OAAjB,CACE,KAAKvE,MAAL,CAAYyE,MADd,EACsB,KAAKxE,YAD3B,EACyC,KAAK2E,kBAD9C,EACkE,KADlE,EACyE,IADzE;AAGD;;AAEDD,EAAAA,WAAW,CAAC3E,MAAD,EAASG,WAAT,EAAsB;AAC/B,SAAKH,MAAL,CAAY6E,IAAZ,CAAiBC,WAAjB,CAA6B,CAA7B;AACA3E,IAAAA,WAAW,CAAC0E,IAAZ,CAAiBC,WAAjB,CAA6B,CAA7B;AACD;;AAEDF,EAAAA,kBAAkB,CAAC5E,MAAD,EAAS+E,WAAT,EAAsB;AACtC,QAAI,KAAK/E,MAAL,CAAYU,eAAZ,IAA+B,CAAC,KAAKV,MAAL,CAAYgF,QAAhD,EAA0D;AACxD,WAAKhF,MAAL,CAAYgF,QAAZ,GAAuB,IAAvB;AACA,WAAKjG,MAAL,CAAYyC,IAAZ,CAAiB,gBAAjB,EAAmCuD,WAAW,CAACtF,EAA/C;AACD;AACF;;AAEDiF,EAAAA,YAAY,CAACD,MAAD,EAASQ,KAAT,EAAgB;AAC1B,QAAI,KAAKjF,MAAL,CAAYU,eAAZ,IAA+B,CAAC,KAAKV,MAAL,CAAYgF,QAAhD,EAA0D;AACxD,WAAKhF,MAAL,CAAYgF,QAAZ,GAAuB,IAAvB;AACA,WAAKjG,MAAL,CAAYyC,IAAZ,CAAiB,iBAAjB,EAAoCyD,KAAK,CAACxF,EAA1C;AACD;AACF;;AAED+E,EAAAA,YAAY,CAACxE,MAAD,EAASa,KAAT,EAAgB;AAC1B;AACA,SAAKiC,eAAL,CAAqB3B,IAArB;AACA,SAAKpC,MAAL,CAAYyC,IAAZ,CAAiB,aAAjB,EAAgCX,KAAK,CAACpB,EAAtC;AACD;;AAED6C,EAAAA,SAAS,GAAG;AACV,SAAK+B,GAAL,GAAW,IAAI3F,GAAJ,CAAQ,IAAR,EAAc,KAAd,EAAqB,YAArB,EAAmC,YAAnC,EAAiD,SAAjD,CAAX;AACD;;AAnUkC;;AAsUrC,eAAeE,SAAf","sourcesContent":["import Phaser from \"phaser\";\nimport PlayerContainer from \"game-core/classes/player/PlayerContainer\";\nimport Chest from \"game-core/classes/Chest\";\nimport Monster from \"game-core/classes/Monster\";\nimport Map from \"game-core/classes/Map\";\nimport SocketService from \"shared/services/socket/socket-service\";\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super(\"Game\");\n\n    this.socket = SocketService?.socket;\n  }\n\n  init() {\n    // Launch instead of start will run scene in parallele - what ever scene active 1st is on bittom lauyet\n    // Start will shut down current and switch to new\n    this.scene.launch(\"Ui\");\n\n\n    // listen for socket event\n    this.listenForSocketEvents();\n  }\n\n  listenForSocketEvents() {\n    // spawn player game objects\n    this.socket.on('currentPlayers', (players) => {\n      Object.keys(players).forEach((id) => {\n        if (players[id].id === this.socket.id) {\n          this.createPlayer(players[id], true);\n          this.addCollisions();\n        } else {\n          this.createPlayer(players[id], false);\n        }\n      });\n    });\n\n    // spawn monster game objects\n    this.socket.on('currentMonsters', (monsters) => {\n      Object.keys(monsters).forEach((id) => {\n        this.spawnMonster(monsters[id]);\n      });\n    });\n\n    // spawn chest game objects\n    this.socket.on('currentChests', (chests) => {\n      Object.keys(chests).forEach((id) => {\n        this.spawnChest(chests[id]);\n      });\n    });\n\n    // spawn player game object\n    this.socket.on('spawnPlayer', (player) => {\n      this.createPlayer(player, false);\n    });\n\n    // a player has moved\n    this.socket.on('playerMoved', (player) => {\n      this.otherPlayers.getChildren().forEach((otherPlayer) => {\n        if (player.id === otherPlayer.id) {\n          otherPlayer.flipX = player.flipX;\n          otherPlayer.setPosition(player.x, player.y);\n          otherPlayer.updateHealthBar();\n          otherPlayer.updateFlipX();\n          otherPlayer.playerAttacking = player.playerAttacking;\n          otherPlayer.currentDirection = player.currentDirection;\n          if (player.playerAttacking) {\n            otherPlayer.attack();\n          }\n        }\n      });\n    });\n\n    this.socket.on('chestSpawned', (chest) => {\n      this.spawnChest(chest);\n    });\n\n    this.socket.on('monsterSpawned', (monster) => {\n      this.spawnMonster(monster);\n    });\n\n    this.socket.on('chestRemoved', (chestId) => {\n      this.chests.getChildren().forEach((chest) => {\n        if (chest.id === chestId) {\n          chest.makeInactive();\n        }\n      });\n    });\n\n    this.socket.on('monsterRemoved', (monsterId) => {\n      this.monsters.getChildren().forEach((monster) => {\n        if (monster.id === monsterId) {\n          monster.makeInactive();\n          this.monsterDeathAudio.play();\n        }\n      });\n    });\n\n    this.socket.on('monsterMovement', (monsters) => {\n      this.monsters.getChildren().forEach((monster) => {\n        Object.keys(monsters).forEach((monsterId) => {\n          if (monster.id === monsterId) {\n            this.physics.moveToObject(monster, monsters[monsterId], 40);\n          }\n        });\n      });\n    });\n\n    this.socket.on('updateScore', (goldAmount) => {\n      this.events.emit('updateScore', goldAmount);\n    });\n\n    this.socket.on('updateMonsterHealth', (monsterId, health) => {\n      this.monsters.getChildren().forEach((monster) => {\n        if (monster.id === monsterId) {\n          monster.updateHealth(health);\n        }\n      });\n    });\n\n    this.socket.on('updatePlayerHealth', (playerId, health) => {\n      if (this.player.id === playerId) {\n        if (health < this.player.health) {\n          this.playerDamageAudio.play();\n        }\n        this.player.updateHealth(health);\n      } else {\n        this.otherPlayers.getChildren().forEach((player) => {\n          if (player.id === playerId) {\n            player.updateHealth(health);\n          }\n        });\n      }\n    });\n\n    this.socket.on('respawnPlayer', (playerObject) => {\n      if (this.player.id === playerObject.id) {\n        this.playerDeathAudio.play();\n        this.player.respawn(playerObject);\n      } else {\n        this.otherPlayers.getChildren().forEach((player) => {\n          if (player.id === playerObject.id) {\n            player.respawn(playerObject);\n          }\n        });\n      }\n    });\n\n    this.socket.on('disconnect', (playerId) => {\n      this.otherPlayers.getChildren().forEach((player) => {\n        if (playerId === player.id) {\n          player.cleanUp();\n        }\n      });\n    });\n\n    this.socket.on('invalidToken', () => {\n      window.alert('Token is no longer valid. Please login again.');\n      window.location.reload();\n    });\n  }\n\n\n\n  create() {\n    this.createMap();\n    this.createAudio();\n    this.createGroups();\n    this.createInput();\n\n    // emit event to server that a new player joined\n    this.socket.emit('newPlayer', { test: 1234 });\n  }\n\n  update() {\n    if (this.player) this.player.update(this.cursors);\n\n    if (this.player) {\n      // emit player movement to the server\n      const {\n        x, y, flipX, playerAttacking, currentDirection,\n      } = this.player;\n      if (this.player.oldPosition && (x !== this.player.oldPosition.x\n        || y !== this.player.oldPosition.y || flipX !== this.player.oldPosition.flipX\n        || playerAttacking !== this.player.oldPosition.playerAttacking)) {\n        this.socket.emit('playerMovement', {\n          x, y, flipX, playerAttacking, currentDirection,\n        });\n      }\n\n      // save old position data\n      this.player.oldPosition = {\n        x: this.player.x,\n        y: this.player.y,\n        flipX: this.player.flipX,\n        playerAttacking: this.player.playerAttacking,\n      };\n    }\n  }\n\n\n  createAudio() {\n    this.goldPickupAudio = this.sound.add('goldSound', { loop: false, volume: 0.3 });\n    this.playerAttackAudio = this.sound.add('playerAttack', { loop: false, volume: 0.01 });\n    this.playerDamageAudio = this.sound.add('playerDamage', { loop: false, volume: 0.2 });\n    this.playerDeathAudio = this.sound.add('playerDeath', { loop: false, volume: 0.2 });\n    this.monsterDeathAudio = this.sound.add('enemyDeath', { loop: false, volume: 0.2 });\n  }\n\n  createPlayer(playerObject, mainPlayer) {\n    const newPlayerGameObject = new PlayerContainer(\n      this,\n      playerObject.x * 2,\n      playerObject.y * 2,\n      'characters',\n      0,\n      playerObject.health,\n      playerObject.maxHealth,\n      playerObject.id,\n      this.playerAttackAudio,\n      mainPlayer,\n    );\n\n    if (!mainPlayer) {\n      this.otherPlayers.add(newPlayerGameObject);\n    } else {\n      this.player = newPlayerGameObject;\n    }\n  }\n\n\n  createGroups() {\n    // create a chest group\n    this.chests = this.physics.add.group();\n    // create a monster group\n    this.monsters = this.physics.add.group();\n    this.monsters.runChildUpdate = true;\n    // create an other players group\n    this.otherPlayers = this.physics.add.group();\n    this.otherPlayers.runChildUpdate = true;\n  }\n\n  spawnChest(chestObject) {\n    let chest = this.chests.getFirstDead();\n    if (!chest) {\n      chest = new Chest(this, chestObject.x * 2, chestObject.y * 2, 'items', 0, chestObject.gold, chestObject.id);\n      // add chest to chests group\n      this.chests.add(chest);\n    } else {\n      chest.coins = chestObject.gold;\n      chest.id = chestObject.id;\n      chest.setPosition(chestObject.x * 2, chestObject.y * 2);\n      chest.makeActive();\n    }\n  }\n\n  spawnMonster(monsterObject) {\n    let monster = this.monsters.getFirstDead();\n    if (!monster) {\n      monster = new Monster(\n        this,\n        monsterObject.x,\n        monsterObject.y,\n        'monsters',\n        monsterObject.frame,\n        monsterObject.id,\n        monsterObject.health,\n        monsterObject.maxHealth,\n      );\n      // add monster to monsters group\n      this.monsters.add(monster);\n    } else {\n      monster.id = monsterObject.id;\n      monster.health = monsterObject.health;\n      monster.maxHealth = monsterObject.maxHealth;\n      monster.setTexture('monsters', monsterObject.frame);\n      monster.setPosition(monsterObject.x, monsterObject.y);\n      monster.makeActive();\n    }\n  }\n\n\n  createInput() {\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  addCollisions() {\n    // check for collisions between the player and the tiled blocked layer\n    this.physics.add.collider(this.player, this.map.blockedLayer);\n    // check for overlaps between player and chest game objects\n    this.physics.add.overlap(this.player, this.chests, this.collectChest, null, this);\n    // check for collisions between the monster group and the tiled blocked layer\n    this.physics.add.collider(this.monsters, this.map.blockedLayer);\n    // check for overlaps between the player's weapon and monster game objects\n    this.physics.add.overlap(this.player.weapon, this.monsters, this.enemyOverlap, null, this);\n    // check for collision betwen the player and other players\n    this.physics.add.collider(this.otherPlayers, this.player, this.pvpCollider, false, this);\n    // check for overlaps between the player's weapon and other player game objects\n    this.physics.add.overlap(\n      this.player.weapon, this.otherPlayers, this.weaponOverlapEnemy, false, this,\n    );\n  }\n\n  pvpCollider(player, otherPlayer) {\n    this.player.body.setVelocity(0);\n    otherPlayer.body.setVelocity(0);\n  }\n\n  weaponOverlapEnemy(player, enemyPlayer) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true;\n      this.socket.emit('attackedPlayer', enemyPlayer.id);\n    }\n  }\n\n  enemyOverlap(weapon, enemy) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true;\n      this.socket.emit('monsterAttacked', enemy.id);\n    }\n  }\n\n  collectChest(player, chest) {\n    // play gold pickup sound\n    this.goldPickupAudio.play();\n    this.socket.emit('pickUpChest', chest.id);\n  }\n\n  createMap() {\n    this.map = new Map(this, \"map\", \"background\", \"background\", \"blocked\");\n  }\n}\n\nexport default GameScene;\n"]},"metadata":{},"sourceType":"module"}