{"ast":null,"code":"import Phaser from \"phaser\";\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super(\"Game\");\n  }\n\n  init() {\n    // Launch instead of start will run scene in parallele - what ever scene active 1st is on bittom lauyet\n    // Start will shut down current and switch to new\n    this.scene.launch(\"Ui\");\n  }\n\n  preload() {}\n\n  create() {\n    this.createMap();\n    this.createAudio();\n    this.createGroups();\n    this.createInput();\n    this.createGameManager();\n  }\n\n  update() {\n    if (this.player) {\n      // On classes update method is not run automatically so we are calling it\n      this.player.update(this.cursors);\n    }\n  }\n\n  createAudio() {\n    this.goldPickupSound = this.sound.add(\"goalSound\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.playerAttackAudio = this.sound.add(\"playerAttack\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.playerDamageAudio = this.sound.add(\"playerDamage\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.playerDeathAudio = this.sound.add(\"playerDeath\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.monsterDeathAudio = this.sound.add(\"enemyDeath\", {\n      loop: false // volume: 0.2,\n\n    });\n  }\n\n  createPlayer(player) {\n    this.player = new PlayerContainer(this, player.x * 2, player.y * 2, \"characters\", 0, player.health, player.maxHealth, player.id, this.playerAttackAudio); // NEW\n  }\n\n  createGroups() {\n    // Chest group\n    this.chests = this.physics.add.group();\n    this.monsters = this.physics.add.group();\n    this.monsters.runChildUpdate = true; // Will run update in all children\n    // Create locations\n    // this.chestPositons = [\n    //   [100, 100],\n    //   [200, 200],\n    //   [300, 300],\n    //   [400, 400],\n    //   [500, 500],\n    // ];\n    // // Max number of chests\n    // this.maxNumber = 3;\n    // for (let i = 0; i < this.maxNumber; i += 1) {\n    //   // SPawn chest\n    //   this.spawnChest();\n    // }\n  }\n\n  spawnChest(chestObj) {\n    // const location =\n    //   this.chestPositons[Math.floor(Math.random() * this.chestPositons.length)];\n    let chest = this.chests.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n\n    if (!chest) {\n      chest = new Chest(this, chestObj.x * 2, chestObj.y * 2, \"items\", 0, chestObj.gold, chestObj.id);\n      this.chests.add(chest);\n      chest.setCollideWorldBounds(true);\n    } else {\n      chest.coins = chestObj.gold;\n      chest.id = chestObj.id;\n      chest.setPosition(chestObj.x * 2, chestObj.y * 2);\n      chest.makeActive();\n    }\n  }\n\n  spawnMonster(monsterObj) {\n    let monster = this.monsters.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n\n    if (!monster) {\n      monster = new Monster(this, monsterObj.x, monsterObj.y, \"monsters\", monsterObj.frame, monsterObj.id, monsterObj.health, monsterObj.maxHealth);\n      this.monsters.add(monster);\n      monster.setCollideWorldBounds(true);\n    } else {\n      // monster.coins = monsterObj.gold;\n      monster.id = monsterObj.id;\n      monster.health = monsterObj.health;\n      monster.maxHealth = monsterObj.maxHealth;\n      monster.setTexture(\"monsters\", monsterObj.frame);\n      monster.setPosition(monsterObj.x, monsterObj.y);\n      monster.makeActive();\n    }\n  }\n\n  createInput() {\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  addCollisions() {\n    this.physics.add.collider(this.player, this.map.blockedLayer);\n    this.physics.add.overlap(this.player, this.chests, this.collectChest, null, this);\n    this.physics.add.collider(this.monsters, this.map.blockedLayer);\n    this.physics.add.overlap(this.player.weapon, this.monsters, this.enemyOverlap, null, this);\n  }\n\n  enemyOverlap(player, enemy) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true; // enemy.makeInactive();\n\n      this.events.emit(\"monsterAttacked\", enemy.id, this.player.id);\n    }\n  }\n\n  collectChest(player, chest) {\n    chest.makeInactive();\n    this.goldPickupSound.play();\n    this.events.emit(\"updateScore\", this.score); // Delayed call so the chest if it spawns in same location as player its not instantly collected\n    // this.time.delayedCall(1000, this.spawnChest, [], this);\n\n    this.events.emit(\"pickupChest\", chest.id, player.id);\n  }\n\n  createMap() {\n    this.map = new Map(this, \"map\", \"background\", \"background\", \"blocked\");\n  }\n\n  createGameManager() {\n    this.events.on(\"spawnPlayer\", player => {\n      this.createPlayer(player);\n      this.addCollisions();\n    });\n    this.events.on(\"chestSpawned\", chest => {\n      this.spawnChest(chest);\n    });\n    this.events.on(\"monsterSpawned\", monster => {\n      this.spawnMonster(monster);\n    });\n    this.events.on(\"monsterRemoved\", monsterID => {\n      this.monsters.getChildren().forEach(monster => {\n        if (monster.id === monsterID) {\n          monster.makeInactive();\n          this.monsterDeathAudio.play();\n        }\n      });\n    });\n    this.events.on(\"chestRemoved\", chestID => {\n      this.chests.getChildren().forEach(chest => {\n        if (chest.id === chestID) {\n          chest.makeInactive();\n        }\n      });\n    });\n    this.events.on(\"updateMonsterHealth\", (monsterID, health) => {\n      this.monsters.getChildren().forEach(monster => {\n        if (monster.id === monsterID) {\n          monster.updateHealth(health);\n        }\n      });\n    });\n    this.events.on(\"monsterMovement\", monsters => {\n      this.monsters.getChildren().forEach(monster => {\n        Object.keys(monsters).forEach(monsterID => {\n          if (monster.id === monsterID) {\n            this.physics.moveToObject(monster, monsters[monsterID], 40);\n          }\n        });\n      });\n    });\n    this.events.on(\"updatePlayerHealth\", (playerID, health) => {\n      this.player.updateHealth(health);\n\n      if (health < this.player.health) {\n        this.playerDamageAudio.play();\n      }\n    });\n    this.events.on(\"respawnPlayer\", player => {\n      this.player.respawn(player);\n      this.playerDeathAudio.play();\n    });\n    this.gameManager = new GameManager(this, this.map.map.objects);\n    this.gameManager.setup();\n  }\n\n}\n\nexport default GameScene;","map":{"version":3,"sources":["/home/odin/Dungeon/Github/phaser-3-exploration/client/src/game-core/scenes/GameScene.js"],"names":["Phaser","GameScene","Scene","constructor","init","scene","launch","preload","create","createMap","createAudio","createGroups","createInput","createGameManager","update","player","cursors","goldPickupSound","sound","add","loop","playerAttackAudio","playerDamageAudio","playerDeathAudio","monsterDeathAudio","createPlayer","PlayerContainer","x","y","health","maxHealth","id","chests","physics","group","monsters","runChildUpdate","spawnChest","chestObj","chest","getFirstDead","Chest","gold","setCollideWorldBounds","coins","setPosition","makeActive","spawnMonster","monsterObj","monster","Monster","frame","setTexture","input","keyboard","createCursorKeys","addCollisions","collider","map","blockedLayer","overlap","collectChest","weapon","enemyOverlap","enemy","playerAttacking","swordHit","events","emit","makeInactive","play","score","Map","on","monsterID","getChildren","forEach","chestID","updateHealth","Object","keys","moveToObject","playerID","respawn","gameManager","GameManager","objects","setup"],"mappings":"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","sourcesContent":["import Phaser from \"phaser\";\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super(\"Game\");\n  }\n\n  init() {\n    // Launch instead of start will run scene in parallele - what ever scene active 1st is on bittom lauyet\n    // Start will shut down current and switch to new\n    this.scene.launch(\"Ui\");\n  }\n\n  preload() {}\n\n  create() {\n    this.createMap();\n    this.createAudio();\n    this.createGroups();\n\n    this.createInput();\n\n    this.createGameManager();\n  }\n  update() {\n    if (this.player) {\n      // On classes update method is not run automatically so we are calling it\n      this.player.update(this.cursors);\n    }\n  }\n\n  createAudio() {\n    this.goldPickupSound = this.sound.add(\"goalSound\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.playerAttackAudio = this.sound.add(\"playerAttack\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.playerDamageAudio = this.sound.add(\"playerDamage\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.playerDeathAudio = this.sound.add(\"playerDeath\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.monsterDeathAudio = this.sound.add(\"enemyDeath\", {\n      loop: false,\n      // volume: 0.2,\n    });\n  }\n\n  createPlayer(player) {\n    this.player = new PlayerContainer(\n      this,\n      player.x * 2,\n      player.y * 2,\n      \"characters\",\n      0,\n      player.health,\n      player.maxHealth,\n      player.id,\n      this.playerAttackAudio\n    ); // NEW\n  }\n\n  createGroups() {\n    // Chest group\n    this.chests = this.physics.add.group();\n    this.monsters = this.physics.add.group();\n    this.monsters.runChildUpdate = true; // Will run update in all children\n    // Create locations\n    // this.chestPositons = [\n    //   [100, 100],\n    //   [200, 200],\n    //   [300, 300],\n    //   [400, 400],\n    //   [500, 500],\n    // ];\n\n    // // Max number of chests\n    // this.maxNumber = 3;\n    // for (let i = 0; i < this.maxNumber; i += 1) {\n    //   // SPawn chest\n    //   this.spawnChest();\n    // }\n  }\n\n  spawnChest(chestObj) {\n    // const location =\n    //   this.chestPositons[Math.floor(Math.random() * this.chestPositons.length)];\n    let chest = this.chests.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n    if (!chest) {\n      chest = new Chest(\n        this,\n        chestObj.x * 2,\n        chestObj.y * 2,\n        \"items\",\n        0,\n        chestObj.gold,\n        chestObj.id\n      );\n      this.chests.add(chest);\n      chest.setCollideWorldBounds(true);\n    } else {\n      chest.coins = chestObj.gold;\n      chest.id = chestObj.id;\n      chest.setPosition(chestObj.x * 2, chestObj.y * 2);\n      chest.makeActive();\n    }\n  }\n\n  spawnMonster(monsterObj) {\n    let monster = this.monsters.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n    if (!monster) {\n      monster = new Monster(\n        this,\n        monsterObj.x,\n        monsterObj.y,\n        \"monsters\",\n        monsterObj.frame,\n        monsterObj.id,\n        monsterObj.health,\n        monsterObj.maxHealth\n      );\n      this.monsters.add(monster);\n      monster.setCollideWorldBounds(true);\n    } else {\n      // monster.coins = monsterObj.gold;\n      monster.id = monsterObj.id;\n      monster.health = monsterObj.health;\n      monster.maxHealth = monsterObj.maxHealth;\n      monster.setTexture(\"monsters\", monsterObj.frame);\n      monster.setPosition(monsterObj.x, monsterObj.y);\n      monster.makeActive();\n    }\n  }\n\n  createInput() {\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  addCollisions() {\n    this.physics.add.collider(this.player, this.map.blockedLayer);\n    this.physics.add.overlap(\n      this.player,\n      this.chests,\n      this.collectChest,\n      null,\n      this\n    );\n    this.physics.add.collider(this.monsters, this.map.blockedLayer);\n    this.physics.add.overlap(\n      this.player.weapon,\n      this.monsters,\n      this.enemyOverlap,\n      null,\n      this\n    );\n  }\n\n  enemyOverlap(player, enemy) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true;\n      // enemy.makeInactive();\n      this.events.emit(\"monsterAttacked\", enemy.id, this.player.id);\n    }\n  }\n\n  collectChest(player, chest) {\n    chest.makeInactive();\n    this.goldPickupSound.play();\n\n    this.events.emit(\"updateScore\", this.score);\n    // Delayed call so the chest if it spawns in same location as player its not instantly collected\n    // this.time.delayedCall(1000, this.spawnChest, [], this);\n    this.events.emit(\"pickupChest\", chest.id, player.id);\n  }\n\n  createMap() {\n    this.map = new Map(this, \"map\", \"background\", \"background\", \"blocked\");\n  }\n\n  createGameManager() {\n    this.events.on(\"spawnPlayer\", (player) => {\n      this.createPlayer(player);\n      this.addCollisions();\n    });\n    this.events.on(\"chestSpawned\", (chest) => {\n      this.spawnChest(chest);\n    });\n    this.events.on(\"monsterSpawned\", (monster) => {\n      this.spawnMonster(monster);\n    });\n\n    this.events.on(\"monsterRemoved\", (monsterID) => {\n      this.monsters.getChildren().forEach((monster) => {\n        if (monster.id === monsterID) {\n          monster.makeInactive();\n          this.monsterDeathAudio.play();\n        }\n      });\n    });\n\n    this.events.on(\"chestRemoved\", (chestID) => {\n      this.chests.getChildren().forEach((chest) => {\n        if (chest.id === chestID) {\n          chest.makeInactive();\n        }\n      });\n    });\n\n    this.events.on(\"updateMonsterHealth\", (monsterID, health) => {\n      this.monsters.getChildren().forEach((monster) => {\n        if (monster.id === monsterID) {\n          monster.updateHealth(health);\n        }\n      });\n    });\n\n    this.events.on(\"monsterMovement\", (monsters) => {\n      this.monsters.getChildren().forEach((monster) => {\n        Object.keys(monsters).forEach((monsterID) => {\n          if (monster.id === monsterID) {\n            this.physics.moveToObject(monster, monsters[monsterID], 40);\n          }\n        });\n      });\n    });\n\n    this.events.on(\"updatePlayerHealth\", (playerID, health) => {\n      this.player.updateHealth(health);\n      if (health < this.player.health) {\n        this.playerDamageAudio.play();\n      }\n    });\n\n    this.events.on(\"respawnPlayer\", (player) => {\n      this.player.respawn(player);\n      this.playerDeathAudio.play();\n    });\n    this.gameManager = new GameManager(this, this.map.map.objects);\n    this.gameManager.setup();\n  }\n}\n\nexport default GameScene;\n"]},"metadata":{},"sourceType":"module"}