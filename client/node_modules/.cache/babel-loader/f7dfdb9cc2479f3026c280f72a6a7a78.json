{"ast":null,"code":"import Phaser from \"phaser\";\nimport PlayerContainer from \"game-core/classes/player/PlayerContainer\";\nimport Chest from \"game-core/classes/Chest\";\nimport Monster from \"game-core/classes/Monster\";\nimport Map from \"game-core/classes/Map\";\nimport SocketService from \"shared/services/socket/socket-service\";\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super(\"Game\");\n    this.socket = SocketService === null || SocketService === void 0 ? void 0 : SocketService.socket;\n  }\n\n  init() {\n    // Launch instead of start will run scene in parallele - what ever scene active 1st is on bittom lauyet\n    // Start will shut down current and switch to new\n    this.scene.launch(\"Ui\"); // Listen for websocket Events\n\n    this.socketListener();\n  }\n\n  socketListener() {\n    // Spawn player game objects\n    this.socket.on(\"currentPlayers\", players => {\n      console.log(\"All current players: \", players);\n      Object.keys(players).forEach(id => {\n        if (players[id].id === this.socket.id) {\n          this.createPlayer(players[id], true);\n          this.addCollisions();\n        } else {\n          this.createPlayer(players[id], false);\n        }\n      });\n    });\n    this.socket.on(\"currentMonsters\", monsters => {\n      Object.keys(monsters).forEach(id => {\n        this.spawnMonster(monsters[id]);\n      });\n    });\n    this.socket.on(\"currentChests\", chests => {\n      Object.keys(chests).forEach(id => {\n        this.spawnChest(chests[id]);\n      });\n    });\n    this.socket.on(\"spawnPlayer\", player => {\n      console.log(\"New Player Event\", player);\n      this.createPlayer(player, false);\n    });\n    this.socket.on(\"playerMoved\", player => {\n      this.otherPlayers.getChildren().forEach(otherPlayer => {\n        if (player.id === otherPlayer.id) {\n          console.log(\"OTHER PLAYER: \", otherPlayer);\n          otherPlayer.flipX = player.flipX;\n          otherPlayer.setPosition(player.x, player.y);\n          otherPlayer.updateHealthBar();\n          otherPlayer.updateFlipX();\n          otherPlayer.playerAttacking = player.playerAttacking;\n          otherPlayer.currentDirection = player.currentDirection;\n\n          if (player.playerAttacking) {\n            otherPlayer.attack();\n          }\n        }\n      });\n    });\n    this.socket.on(\"chestSpawned\", chest => {\n      this.spawnChest(chest);\n    });\n    this.socket.on(\"monsterSpawned\", monster => {\n      this.spawnMonster(monster);\n    });\n    this.socket.on(\"chestRemoved\", chestID => {\n      this.chests.getChildren().forEach(chest => {\n        if (chest.id === chestID) {\n          chest.makeInactive();\n        }\n      });\n    });\n    this.socket.on(\"monsterRemoved\", monsterID => {\n      this.monsters.getChildren().forEach(monster => {\n        if (monster.id === monsterID) {\n          monster.makeInactive();\n          this.monsterDeathAudio.play();\n        }\n      });\n    });\n    this.socket.on(\"monsterMovement\", monsters => {\n      this.monsters.getChildren().forEach(monster => {\n        Object.keys(monsters).forEach(monsterID => {\n          if (monster.id === monsterID) {\n            this.physics.moveToObject(monster, monsters[monsterID], 40);\n          }\n        });\n      });\n    });\n    this.socket.on(\"updateScore\", goldAmount => {\n      this.events.emit(\"updateScore\", goldAmount);\n    });\n    this.socket.on(\"updateMonsterHealth\", (monsterID, health) => {\n      this.monsters.getChildren().forEach(monster => {\n        if (monster.id === monsterID) {\n          monster.updateHealth(health);\n        }\n      });\n    });\n    this.socket.on(\"updatePlayerHealth\", (playerID, health) => {\n      if (this.player.id === playerID) {\n        if (health < this.player.health) {\n          this.playerDamageAudio.play();\n        }\n\n        this.player.updateHealth(health);\n      } else {\n        this.otherPlayers.getChildren().forEach(player => {\n          if (player.id === playerID) {\n            player.updateHealth(health);\n          }\n        });\n      }\n    });\n    this.socket.on(\"respawnPlayer\", playerObject => {\n      if (this.player.id === playerObject.id) {\n        this.player.respawn(playerObject);\n        this.playerDeathAudio.play();\n      } else {\n        this.otherPlayers.getChildren().forEach(player => {\n          if (player.id === playerObject.id) {\n            player.respawn(playerObject);\n          }\n        });\n      }\n    });\n    this.socket.on(\"disconnect\", playerID => {\n      this.otherPlayers.getChildren().forEach(player => {\n        if (playerID === player.id) {\n          player.cleanup();\n        }\n      });\n    });\n  }\n\n  preload() {}\n\n  create() {\n    this.createMap();\n    this.createAudio();\n    this.createGroups();\n    this.createInput();\n    this.socket.emit(\"newPlayer\");\n  }\n\n  update() {\n    if (this.player) {\n      // On classes update method is not run automatically so we are calling it\n      this.player.update(this.cursors);\n    } // Check if current pos or flip x is different to rec to see if player moved\n\n\n    if (this.player) {\n      var _this$player$x, _this$player, _this$player$y, _this$player2, _this$player3, _this$player4;\n\n      // emit movement to server\n      const {\n        x,\n        y,\n        flipX,\n        playerAttacking,\n        currentDirection\n      } = this.player;\n\n      if (this.player.oldPosition && (x !== this.player.oldPosition.x || y !== this.player.oldPosition.y || flipX !== this.player.oldPosition.flipX || playerAttacking !== this.player.oldPosition.playerAttacking)) {\n        this.socket.emit(\"playerMovement\", {\n          x,\n          y,\n          flipX,\n          playerAttacking,\n          currentDirection\n        });\n      } // Save old position\n\n\n      this.player.oldPosition = {\n        x: (_this$player$x = (_this$player = this.player) === null || _this$player === void 0 ? void 0 : _this$player.x) !== null && _this$player$x !== void 0 ? _this$player$x : 0,\n        y: (_this$player$y = (_this$player2 = this.player) === null || _this$player2 === void 0 ? void 0 : _this$player2.y) !== null && _this$player$y !== void 0 ? _this$player$y : 0,\n        flipX: (_this$player3 = this.player) === null || _this$player3 === void 0 ? void 0 : _this$player3.flipX,\n        playerAttacking: (_this$player4 = this.player) === null || _this$player4 === void 0 ? void 0 : _this$player4.playerAttacking\n      };\n    }\n  }\n\n  createAudio() {\n    this.goldPickupSound = this.sound.add(\"goalSound\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.playerAttackAudio = this.sound.add(\"playerAttack\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.playerDamageAudio = this.sound.add(\"playerDamage\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.playerDeathAudio = this.sound.add(\"playerDeath\", {\n      loop: false // volume: 0.2,\n\n    });\n    this.monsterDeathAudio = this.sound.add(\"enemyDeath\", {\n      loop: false // volume: 0.2,\n\n    });\n  }\n\n  createPlayer(playerObject, mainPlayer) {\n    const newPlayerGameObject = new PlayerContainer(this, playerObject.x * 2, playerObject.y * 2, \"characters\", 0, playerObject.health, playerObject.maxHealth, playerObject.id, this.playerAttackAudio, mainPlayer); // NEW\n\n    if (!mainPlayer) {\n      this.otherPlayers.add(newPlayerGameObject);\n    } else {\n      this.player = newPlayerGameObject;\n    }\n  }\n\n  createGroups() {\n    // Chest group\n    this.chests = this.physics.add.group();\n    this.monsters = this.physics.add.group();\n    this.monsters.runChildUpdate = true; // Will run update in all children\n    // Create locations\n    // this.chestPositons = [\n    //   [100, 100],\n    //   [200, 200],\n    //   [300, 300],\n    //   [400, 400],\n    //   [500, 500],\n    // ];\n    // // Max number of chests\n    // this.maxNumber = 3;\n    // for (let i = 0; i < this.maxNumber; i += 1) {\n    //   // SPawn chest\n    //   this.spawnChest();\n    // }\n    // Other plays\n\n    this.otherPlayers = this.physics.add.group();\n    this.otherPlayers.runChildUpdate = true;\n  }\n\n  spawnChest(chestObj) {\n    // const location =\n    //   this.chestPositons[Math.floor(Math.random() * this.chestPositons.length)];\n    let chest = this.chests.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n\n    if (!chest) {\n      chest = new Chest(this, chestObj.x * 2, chestObj.y * 2, \"items\", 0, chestObj.gold, chestObj.id);\n      this.chests.add(chest);\n      chest.setCollideWorldBounds(true);\n    } else {\n      chest.coins = chestObj.gold;\n      chest.id = chestObj.id;\n      chest.setPosition(chestObj.x * 2, chestObj.y * 2);\n      chest.makeActive();\n    }\n  }\n\n  spawnMonster(monsterObj) {\n    let monster = this.monsters.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n\n    if (!monster) {\n      monster = new Monster(this, monsterObj.x, monsterObj.y, \"monsters\", monsterObj.frame, monsterObj.id, monsterObj.health, monsterObj.maxHealth);\n      this.monsters.add(monster);\n      monster.setCollideWorldBounds(true);\n    } else {\n      // monster.coins = monsterObj.gold;\n      monster.id = monsterObj.id;\n      monster.health = monsterObj.health;\n      monster.maxHealth = monsterObj.maxHealth;\n      monster.setTexture(\"monsters\", monsterObj.frame);\n      monster.setPosition(monsterObj.x, monsterObj.y);\n      monster.makeActive();\n    }\n  }\n\n  createInput() {\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  addCollisions() {\n    this.physics.add.collider(this.player, this.map.blockedLayer);\n    this.physics.add.overlap(this.player, this.chests, this.collectChest, null, this);\n    this.physics.add.collider(this.monsters, this.map.blockedLayer);\n    this.physics.add.overlap(this.player.weapon, this.monsters, this.enemyOverlap, null, this);\n  }\n\n  enemyOverlap(player, enemy) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true; // enemy.makeInactive();\n\n      this.socket.emit(\"monsterAttacked\", enemy.id);\n    }\n  }\n\n  collectChest(player, chest) {\n    chest.makeInactive();\n    this.goldPickupSound.play();\n    this.socket.emit(\"updateScore\", this.score); // Delayed call so the chest if it spawns in same location as player its not instantly collected\n    // this.time.delayedCall(1000, this.spawnChest, [], this);\n\n    this.socket.emit(\"pickupChest\", chest.id);\n  }\n\n  createMap() {\n    this.map = new Map(this, \"map\", \"background\", \"background\", \"blocked\");\n  }\n\n}\n\nexport default GameScene;","map":{"version":3,"sources":["/home/odin/Dungeon/Github/phaser-3-exploration/client/src/game-core/scenes/GameScene.js"],"names":["Phaser","PlayerContainer","Chest","Monster","Map","SocketService","GameScene","Scene","constructor","socket","init","scene","launch","socketListener","on","players","console","log","Object","keys","forEach","id","createPlayer","addCollisions","monsters","spawnMonster","chests","spawnChest","player","otherPlayers","getChildren","otherPlayer","flipX","setPosition","x","y","updateHealthBar","updateFlipX","playerAttacking","currentDirection","attack","chest","monster","chestID","makeInactive","monsterID","monsterDeathAudio","play","physics","moveToObject","goldAmount","events","emit","health","updateHealth","playerID","playerDamageAudio","playerObject","respawn","playerDeathAudio","cleanup","preload","create","createMap","createAudio","createGroups","createInput","update","cursors","oldPosition","goldPickupSound","sound","add","loop","playerAttackAudio","mainPlayer","newPlayerGameObject","maxHealth","group","runChildUpdate","chestObj","getFirstDead","gold","setCollideWorldBounds","coins","makeActive","monsterObj","frame","setTexture","input","keyboard","createCursorKeys","collider","map","blockedLayer","overlap","collectChest","weapon","enemyOverlap","enemy","swordHit","score"],"mappings":"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","sourcesContent":["import Phaser from \"phaser\";\nimport PlayerContainer from \"game-core/classes/player/PlayerContainer\";\nimport Chest from \"game-core/classes/Chest\";\nimport Monster from \"game-core/classes/Monster\";\nimport Map from \"game-core/classes/Map\";\nimport SocketService from \"shared/services/socket/socket-service\";\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super(\"Game\");\n\n    this.socket = SocketService?.socket;\n  }\n\n  init() {\n    // Launch instead of start will run scene in parallele - what ever scene active 1st is on bittom lauyet\n    // Start will shut down current and switch to new\n    this.scene.launch(\"Ui\");\n\n    // Listen for websocket Events\n    this.socketListener();\n  }\n\n  socketListener() {\n    // Spawn player game objects\n    this.socket.on(\"currentPlayers\", (players) => {\n      console.log(\"All current players: \", players);\n      Object.keys(players).forEach((id) => {\n        if (players[id].id === this.socket.id) {\n          this.createPlayer(players[id], true);\n          this.addCollisions();\n        } else {\n          this.createPlayer(players[id], false);\n        }\n      });\n    });\n    this.socket.on(\"currentMonsters\", (monsters) => {\n      Object.keys(monsters).forEach((id) => {\n        this.spawnMonster(monsters[id]);\n      });\n    });\n    this.socket.on(\"currentChests\", (chests) => {\n      Object.keys(chests).forEach((id) => {\n        this.spawnChest(chests[id]);\n      });\n    });\n    this.socket.on(\"spawnPlayer\", (player) => {\n      console.log(\"New Player Event\", player);\n      this.createPlayer(player, false);\n    });\n\n    this.socket.on(\"playerMoved\", (player) => {\n      this.otherPlayers.getChildren().forEach((otherPlayer) => {\n        if (player.id === otherPlayer.id) {\n          console.log(\"OTHER PLAYER: \", otherPlayer);\n          otherPlayer.flipX = player.flipX;\n          otherPlayer.setPosition(player.x, player.y);\n          otherPlayer.updateHealthBar();\n          otherPlayer.updateFlipX();\n          otherPlayer.playerAttacking = player.playerAttacking;\n          otherPlayer.currentDirection = player.currentDirection;\n          if (player.playerAttacking) {\n            otherPlayer.attack();\n          }\n        }\n      });\n    });\n\n    this.socket.on(\"chestSpawned\", (chest) => {\n      this.spawnChest(chest);\n    });\n    this.socket.on(\"monsterSpawned\", (monster) => {\n      this.spawnMonster(monster);\n    });\n\n    this.socket.on(\"chestRemoved\", (chestID) => {\n      this.chests.getChildren().forEach((chest) => {\n        if (chest.id === chestID) {\n          chest.makeInactive();\n        }\n      });\n    });\n\n    this.socket.on(\"monsterRemoved\", (monsterID) => {\n      this.monsters.getChildren().forEach((monster) => {\n        if (monster.id === monsterID) {\n          monster.makeInactive();\n          this.monsterDeathAudio.play();\n        }\n      });\n    });\n\n    this.socket.on(\"monsterMovement\", (monsters) => {\n      this.monsters.getChildren().forEach((monster) => {\n        Object.keys(monsters).forEach((monsterID) => {\n          if (monster.id === monsterID) {\n            this.physics.moveToObject(monster, monsters[monsterID], 40);\n          }\n        });\n      });\n    });\n\n    this.socket.on(\"updateScore\", (goldAmount) => {\n      this.events.emit(\"updateScore\", goldAmount);\n    });\n\n    this.socket.on(\"updateMonsterHealth\", (monsterID, health) => {\n      this.monsters.getChildren().forEach((monster) => {\n        if (monster.id === monsterID) {\n          monster.updateHealth(health);\n        }\n      });\n    });\n\n    this.socket.on(\"updatePlayerHealth\", (playerID, health) => {\n      if (this.player.id === playerID) {\n        if (health < this.player.health) {\n          this.playerDamageAudio.play();\n        }\n        this.player.updateHealth(health);\n      } else {\n        this.otherPlayers.getChildren().forEach((player) => {\n          if (player.id === playerID) {\n            player.updateHealth(health);\n          }\n        });\n      }\n    });\n\n    this.socket.on(\"respawnPlayer\", (playerObject) => {\n      if (this.player.id === playerObject.id) {\n        this.player.respawn(playerObject);\n        this.playerDeathAudio.play();\n      } else {\n        this.otherPlayers.getChildren().forEach((player) => {\n          if (player.id === playerObject.id) {\n            player.respawn(playerObject);\n          }\n        });\n      }\n    });\n\n    this.socket.on(\"disconnect\", (playerID) => {\n      this.otherPlayers.getChildren().forEach((player) => {\n        if (playerID === player.id) {\n          player.cleanup();\n        }\n      });\n    });\n  }\n\n  preload() {}\n\n  create() {\n    this.createMap();\n    this.createAudio();\n    this.createGroups();\n\n    this.createInput();\n\n    this.socket.emit(\"newPlayer\");\n  }\n  update() {\n    if (this.player) {\n      // On classes update method is not run automatically so we are calling it\n      this.player.update(this.cursors);\n    }\n\n    // Check if current pos or flip x is different to rec to see if player moved\n    if (this.player) {\n      // emit movement to server\n      const { x, y, flipX, playerAttacking, currentDirection } = this.player;\n      if (\n        this.player.oldPosition &&\n        (x !== this.player.oldPosition.x ||\n          y !== this.player.oldPosition.y ||\n          flipX !== this.player.oldPosition.flipX ||\n          playerAttacking !== this.player.oldPosition.playerAttacking)\n      ) {\n        this.socket.emit(\"playerMovement\", {\n          x,\n          y,\n          flipX,\n          playerAttacking,\n          currentDirection,\n        });\n      }\n\n      // Save old position\n      this.player.oldPosition = {\n        x: this.player?.x ?? 0,\n        y: this.player?.y ?? 0,\n        flipX: this.player?.flipX,\n        playerAttacking: this.player?.playerAttacking,\n      };\n    }\n  }\n\n  createAudio() {\n    this.goldPickupSound = this.sound.add(\"goalSound\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.playerAttackAudio = this.sound.add(\"playerAttack\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.playerDamageAudio = this.sound.add(\"playerDamage\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.playerDeathAudio = this.sound.add(\"playerDeath\", {\n      loop: false,\n      // volume: 0.2,\n    });\n    this.monsterDeathAudio = this.sound.add(\"enemyDeath\", {\n      loop: false,\n      // volume: 0.2,\n    });\n  }\n\n  createPlayer(playerObject, mainPlayer) {\n    const newPlayerGameObject = new PlayerContainer(\n      this,\n      playerObject.x * 2,\n      playerObject.y * 2,\n      \"characters\",\n      0,\n      playerObject.health,\n      playerObject.maxHealth,\n      playerObject.id,\n      this.playerAttackAudio,\n      mainPlayer\n    ); // NEW\n\n    if (!mainPlayer) {\n      this.otherPlayers.add(newPlayerGameObject);\n    } else {\n      this.player = newPlayerGameObject;\n    }\n  }\n\n  createGroups() {\n    // Chest group\n    this.chests = this.physics.add.group();\n    this.monsters = this.physics.add.group();\n    this.monsters.runChildUpdate = true; // Will run update in all children\n    // Create locations\n    // this.chestPositons = [\n    //   [100, 100],\n    //   [200, 200],\n    //   [300, 300],\n    //   [400, 400],\n    //   [500, 500],\n    // ];\n\n    // // Max number of chests\n    // this.maxNumber = 3;\n    // for (let i = 0; i < this.maxNumber; i += 1) {\n    //   // SPawn chest\n    //   this.spawnChest();\n    // }\n\n    // Other plays\n    this.otherPlayers = this.physics.add.group();\n    this.otherPlayers.runChildUpdate = true;\n  }\n\n  spawnChest(chestObj) {\n    // const location =\n    //   this.chestPositons[Math.floor(Math.random() * this.chestPositons.length)];\n    let chest = this.chests.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n    if (!chest) {\n      chest = new Chest(\n        this,\n        chestObj.x * 2,\n        chestObj.y * 2,\n        \"items\",\n        0,\n        chestObj.gold,\n        chestObj.id\n      );\n      this.chests.add(chest);\n      chest.setCollideWorldBounds(true);\n    } else {\n      chest.coins = chestObj.gold;\n      chest.id = chestObj.id;\n      chest.setPosition(chestObj.x * 2, chestObj.y * 2);\n      chest.makeActive();\n    }\n  }\n\n  spawnMonster(monsterObj) {\n    let monster = this.monsters.getFirstDead(); // Loop through chest group and get first inactive object in array\n    // If none active - phase will return null\n    if (!monster) {\n      monster = new Monster(\n        this,\n        monsterObj.x,\n        monsterObj.y,\n        \"monsters\",\n        monsterObj.frame,\n        monsterObj.id,\n        monsterObj.health,\n        monsterObj.maxHealth\n      );\n      this.monsters.add(monster);\n      monster.setCollideWorldBounds(true);\n    } else {\n      // monster.coins = monsterObj.gold;\n      monster.id = monsterObj.id;\n      monster.health = monsterObj.health;\n      monster.maxHealth = monsterObj.maxHealth;\n      monster.setTexture(\"monsters\", monsterObj.frame);\n      monster.setPosition(monsterObj.x, monsterObj.y);\n      monster.makeActive();\n    }\n  }\n\n  createInput() {\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  addCollisions() {\n    this.physics.add.collider(this.player, this.map.blockedLayer);\n    this.physics.add.overlap(\n      this.player,\n      this.chests,\n      this.collectChest,\n      null,\n      this\n    );\n    this.physics.add.collider(this.monsters, this.map.blockedLayer);\n    this.physics.add.overlap(\n      this.player.weapon,\n      this.monsters,\n      this.enemyOverlap,\n      null,\n      this\n    );\n  }\n\n  enemyOverlap(player, enemy) {\n    if (this.player.playerAttacking && !this.player.swordHit) {\n      this.player.swordHit = true;\n      // enemy.makeInactive();\n      this.socket.emit(\"monsterAttacked\", enemy.id);\n    }\n  }\n\n  collectChest(player, chest) {\n    chest.makeInactive();\n    this.goldPickupSound.play();\n\n    this.socket.emit(\"updateScore\", this.score);\n    // Delayed call so the chest if it spawns in same location as player its not instantly collected\n    // this.time.delayedCall(1000, this.spawnChest, [], this);\n    this.socket.emit(\"pickupChest\", chest.id);\n  }\n\n  createMap() {\n    this.map = new Map(this, \"map\", \"background\", \"background\", \"blocked\");\n  }\n}\n\nexport default GameScene;\n"]},"metadata":{},"sourceType":"module"}